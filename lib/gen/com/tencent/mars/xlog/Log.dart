// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../../../_init.dart";

/// from: com.tencent.mars.xlog.Log$LogImp
class Log_LogImp extends jni.JObject {
  @override
  late final jni.JObjType<Log_LogImp> $type = type;

  Log_LogImp.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Log_LogImpType();
  static final _logV = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__logV")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void logV(long j, java.lang.String string, java.lang.String string1, java.lang.String string2, int i, int i1, long j1, long j2, java.lang.String string3)
  void logV(
    int j,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i,
    int i1,
    int j1,
    int j2,
    jni.JString string3,
  ) {
    return _logV(reference, j, string.reference, string1.reference,
            string2.reference, i, i1, j1, j2, string3.reference)
        .check();
  }

  static final _logI = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__logI")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void logI(long j, java.lang.String string, java.lang.String string1, java.lang.String string2, int i, int i1, long j1, long j2, java.lang.String string3)
  void logI(
    int j,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i,
    int i1,
    int j1,
    int j2,
    jni.JString string3,
  ) {
    return _logI(reference, j, string.reference, string1.reference,
            string2.reference, i, i1, j1, j2, string3.reference)
        .check();
  }

  static final _logD = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__logD")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void logD(long j, java.lang.String string, java.lang.String string1, java.lang.String string2, int i, int i1, long j1, long j2, java.lang.String string3)
  void logD(
    int j,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i,
    int i1,
    int j1,
    int j2,
    jni.JString string3,
  ) {
    return _logD(reference, j, string.reference, string1.reference,
            string2.reference, i, i1, j1, j2, string3.reference)
        .check();
  }

  static final _logW = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__logW")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void logW(long j, java.lang.String string, java.lang.String string1, java.lang.String string2, int i, int i1, long j1, long j2, java.lang.String string3)
  void logW(
    int j,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i,
    int i1,
    int j1,
    int j2,
    jni.JString string3,
  ) {
    return _logW(reference, j, string.reference, string1.reference,
            string2.reference, i, i1, j1, j2, string3.reference)
        .check();
  }

  static final _logE = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__logE")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void logE(long j, java.lang.String string, java.lang.String string1, java.lang.String string2, int i, int i1, long j1, long j2, java.lang.String string3)
  void logE(
    int j,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i,
    int i1,
    int j1,
    int j2,
    jni.JString string3,
  ) {
    return _logE(reference, j, string.reference, string1.reference,
            string2.reference, i, i1, j1, j2, string3.reference)
        .check();
  }

  static final _logF = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__logF")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void logF(long j, java.lang.String string, java.lang.String string1, java.lang.String string2, int i, int i1, long j1, long j2, java.lang.String string3)
  void logF(
    int j,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i,
    int i1,
    int j1,
    int j2,
    jni.JString string3,
  ) {
    return _logF(reference, j, string.reference, string1.reference,
            string2.reference, i, i1, j1, j2, string3.reference)
        .check();
  }

  static final _getLogLevel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int64)>>("Log_LogImp__getLogLevel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public abstract int getLogLevel(long j)
  int getLogLevel(
    int j,
  ) {
    return _getLogLevel(reference, j).integer;
  }

  static final _setAppenderMode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int32)>>("Log_LogImp__setAppenderMode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setAppenderMode(long j, int i)
  void setAppenderMode(
    int j,
    int i,
  ) {
    return _setAppenderMode(reference, j, i).check();
  }

  static final _openLogInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Log_LogImp__openLogInstance")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public abstract long openLogInstance(int i, int i1, java.lang.String string, java.lang.String string1, java.lang.String string2, int i2)
  int openLogInstance(
    int i,
    int i1,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i2,
  ) {
    return _openLogInstance(reference, i, i1, string.reference,
            string1.reference, string2.reference, i2)
        .long;
  }

  static final _getXlogInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__getXlogInstance")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract long getXlogInstance(java.lang.String string)
  int getXlogInstance(
    jni.JString string,
  ) {
    return _getXlogInstance(reference, string.reference).long;
  }

  static final _releaseXlogInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogImp__releaseXlogInstance")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void releaseXlogInstance(java.lang.String string)
  void releaseXlogInstance(
    jni.JString string,
  ) {
    return _releaseXlogInstance(reference, string.reference).check();
  }

  static final _appenderOpen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Log_LogImp__appenderOpen")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int)>();

  /// from: public abstract void appenderOpen(int i, int i1, java.lang.String string, java.lang.String string1, java.lang.String string2, int i2)
  void appenderOpen(
    int i,
    int i1,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i2,
  ) {
    return _appenderOpen(reference, i, i1, string.reference, string1.reference,
            string2.reference, i2)
        .check();
  }

  static final _appenderClose = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log_LogImp__appenderClose")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void appenderClose()
  void appenderClose() {
    return _appenderClose(reference).check();
  }

  static final _appenderFlush = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Uint8)>>("Log_LogImp__appenderFlush")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void appenderFlush(long j, boolean z)
  void appenderFlush(
    int j,
    bool z,
  ) {
    return _appenderFlush(reference, j, z ? 1 : 0).check();
  }

  static final _setConsoleLogOpen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Uint8)>>("Log_LogImp__setConsoleLogOpen")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setConsoleLogOpen(long j, boolean z)
  void setConsoleLogOpen(
    int j,
    bool z,
  ) {
    return _setConsoleLogOpen(reference, j, z ? 1 : 0).check();
  }

  static final _setMaxFileSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("Log_LogImp__setMaxFileSize")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setMaxFileSize(long j, long j1)
  void setMaxFileSize(
    int j,
    int j1,
  ) {
    return _setMaxFileSize(reference, j, j1).check();
  }

  static final _setMaxAliveTime = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Int64)>>("Log_LogImp__setMaxAliveTime")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public abstract void setMaxAliveTime(long j, long j1)
  void setMaxAliveTime(
    int j,
    int j1,
  ) {
    return _setMaxAliveTime(reference, j, j1).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Log_LogImpImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"logV(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIJJLjava/lang/String;)V") {
        _$impls[$p]!.logV(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[8].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"logI(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIJJLjava/lang/String;)V") {
        _$impls[$p]!.logI(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[8].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"logD(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIJJLjava/lang/String;)V") {
        _$impls[$p]!.logD(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[8].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"logW(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIJJLjava/lang/String;)V") {
        _$impls[$p]!.logW(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[8].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"logE(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIJJLjava/lang/String;)V") {
        _$impls[$p]!.logE(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[8].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"logF(JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;IIJJLjava/lang/String;)V") {
        _$impls[$p]!.logF(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[6]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[7]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[8].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"getLogLevel(J)I") {
        final $r = _$impls[$p]!.getLogLevel(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni.JInteger($r).toPointer();
      }
      if ($d == r"setAppenderMode(JI)V") {
        _$impls[$p]!.setAppenderMode(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"openLogInstance(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;I)J") {
        final $r = _$impls[$p]!.openLogInstance(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.JLong($r).toPointer();
      }
      if ($d == r"getXlogInstance(Ljava/lang/String;)J") {
        final $r = _$impls[$p]!.getXlogInstance(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.JLong($r).toPointer();
      }
      if ($d == r"releaseXlogInstance(Ljava/lang/String;)V") {
        _$impls[$p]!.releaseXlogInstance(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r"appenderOpen(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V") {
        _$impls[$p]!.appenderOpen(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[3].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[4].castTo(const jni.JStringType(), releaseOriginal: true),
          $a[5]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"appenderClose()V") {
        _$impls[$p]!.appenderClose();
        return jni.nullptr;
      }
      if ($d == r"appenderFlush(JZ)V") {
        _$impls[$p]!.appenderFlush(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"setConsoleLogOpen(JZ)V") {
        _$impls[$p]!.setConsoleLogOpen(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JBooleanType(), releaseOriginal: true)
              .booleanValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"setMaxFileSize(JJ)V") {
        _$impls[$p]!.setMaxFileSize(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"setMaxAliveTime(JJ)V") {
        _$impls[$p]!.setMaxAliveTime(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Log_LogImp.implement(
    $Log_LogImpImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Log_LogImp.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.tencent.mars.xlog.Log$LogImp",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Log_LogImpImpl {
  factory $Log_LogImpImpl({
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logV,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logI,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logD,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logW,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logE,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logF,
    required int Function(int j) getLogLevel,
    required void Function(int j, int i) setAppenderMode,
    required int Function(int i, int i1, jni.JString string,
            jni.JString string1, jni.JString string2, int i2)
        openLogInstance,
    required int Function(jni.JString string) getXlogInstance,
    required void Function(jni.JString string) releaseXlogInstance,
    required void Function(int i, int i1, jni.JString string,
            jni.JString string1, jni.JString string2, int i2)
        appenderOpen,
    required void Function() appenderClose,
    required void Function(int j, bool z) appenderFlush,
    required void Function(int j, bool z) setConsoleLogOpen,
    required void Function(int j, int j1) setMaxFileSize,
    required void Function(int j, int j1) setMaxAliveTime,
  }) = _$Log_LogImpImpl;

  void logV(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3);
  void logI(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3);
  void logD(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3);
  void logW(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3);
  void logE(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3);
  void logF(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3);
  int getLogLevel(int j);
  void setAppenderMode(int j, int i);
  int openLogInstance(int i, int i1, jni.JString string, jni.JString string1,
      jni.JString string2, int i2);
  int getXlogInstance(jni.JString string);
  void releaseXlogInstance(jni.JString string);
  void appenderOpen(int i, int i1, jni.JString string, jni.JString string1,
      jni.JString string2, int i2);
  void appenderClose();
  void appenderFlush(int j, bool z);
  void setConsoleLogOpen(int j, bool z);
  void setMaxFileSize(int j, int j1);
  void setMaxAliveTime(int j, int j1);
}

class _$Log_LogImpImpl implements $Log_LogImpImpl {
  _$Log_LogImpImpl({
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logV,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logI,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logD,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logW,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logE,
    required void Function(
            int j,
            jni.JString string,
            jni.JString string1,
            jni.JString string2,
            int i,
            int i1,
            int j1,
            int j2,
            jni.JString string3)
        logF,
    required int Function(int j) getLogLevel,
    required void Function(int j, int i) setAppenderMode,
    required int Function(int i, int i1, jni.JString string,
            jni.JString string1, jni.JString string2, int i2)
        openLogInstance,
    required int Function(jni.JString string) getXlogInstance,
    required void Function(jni.JString string) releaseXlogInstance,
    required void Function(int i, int i1, jni.JString string,
            jni.JString string1, jni.JString string2, int i2)
        appenderOpen,
    required void Function() appenderClose,
    required void Function(int j, bool z) appenderFlush,
    required void Function(int j, bool z) setConsoleLogOpen,
    required void Function(int j, int j1) setMaxFileSize,
    required void Function(int j, int j1) setMaxAliveTime,
  })  : _logV = logV,
        _logI = logI,
        _logD = logD,
        _logW = logW,
        _logE = logE,
        _logF = logF,
        _getLogLevel = getLogLevel,
        _setAppenderMode = setAppenderMode,
        _openLogInstance = openLogInstance,
        _getXlogInstance = getXlogInstance,
        _releaseXlogInstance = releaseXlogInstance,
        _appenderOpen = appenderOpen,
        _appenderClose = appenderClose,
        _appenderFlush = appenderFlush,
        _setConsoleLogOpen = setConsoleLogOpen,
        _setMaxFileSize = setMaxFileSize,
        _setMaxAliveTime = setMaxAliveTime;

  final void Function(
      int j,
      jni.JString string,
      jni.JString string1,
      jni.JString string2,
      int i,
      int i1,
      int j1,
      int j2,
      jni.JString string3) _logV;
  final void Function(
      int j,
      jni.JString string,
      jni.JString string1,
      jni.JString string2,
      int i,
      int i1,
      int j1,
      int j2,
      jni.JString string3) _logI;
  final void Function(
      int j,
      jni.JString string,
      jni.JString string1,
      jni.JString string2,
      int i,
      int i1,
      int j1,
      int j2,
      jni.JString string3) _logD;
  final void Function(
      int j,
      jni.JString string,
      jni.JString string1,
      jni.JString string2,
      int i,
      int i1,
      int j1,
      int j2,
      jni.JString string3) _logW;
  final void Function(
      int j,
      jni.JString string,
      jni.JString string1,
      jni.JString string2,
      int i,
      int i1,
      int j1,
      int j2,
      jni.JString string3) _logE;
  final void Function(
      int j,
      jni.JString string,
      jni.JString string1,
      jni.JString string2,
      int i,
      int i1,
      int j1,
      int j2,
      jni.JString string3) _logF;
  final int Function(int j) _getLogLevel;
  final void Function(int j, int i) _setAppenderMode;
  final int Function(int i, int i1, jni.JString string, jni.JString string1,
      jni.JString string2, int i2) _openLogInstance;
  final int Function(jni.JString string) _getXlogInstance;
  final void Function(jni.JString string) _releaseXlogInstance;
  final void Function(int i, int i1, jni.JString string, jni.JString string1,
      jni.JString string2, int i2) _appenderOpen;
  final void Function() _appenderClose;
  final void Function(int j, bool z) _appenderFlush;
  final void Function(int j, bool z) _setConsoleLogOpen;
  final void Function(int j, int j1) _setMaxFileSize;
  final void Function(int j, int j1) _setMaxAliveTime;

  void logV(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3) {
    return _logV(j, string, string1, string2, i, i1, j1, j2, string3);
  }

  void logI(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3) {
    return _logI(j, string, string1, string2, i, i1, j1, j2, string3);
  }

  void logD(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3) {
    return _logD(j, string, string1, string2, i, i1, j1, j2, string3);
  }

  void logW(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3) {
    return _logW(j, string, string1, string2, i, i1, j1, j2, string3);
  }

  void logE(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3) {
    return _logE(j, string, string1, string2, i, i1, j1, j2, string3);
  }

  void logF(int j, jni.JString string, jni.JString string1, jni.JString string2,
      int i, int i1, int j1, int j2, jni.JString string3) {
    return _logF(j, string, string1, string2, i, i1, j1, j2, string3);
  }

  int getLogLevel(int j) {
    return _getLogLevel(j);
  }

  void setAppenderMode(int j, int i) {
    return _setAppenderMode(j, i);
  }

  int openLogInstance(int i, int i1, jni.JString string, jni.JString string1,
      jni.JString string2, int i2) {
    return _openLogInstance(i, i1, string, string1, string2, i2);
  }

  int getXlogInstance(jni.JString string) {
    return _getXlogInstance(string);
  }

  void releaseXlogInstance(jni.JString string) {
    return _releaseXlogInstance(string);
  }

  void appenderOpen(int i, int i1, jni.JString string, jni.JString string1,
      jni.JString string2, int i2) {
    return _appenderOpen(i, i1, string, string1, string2, i2);
  }

  void appenderClose() {
    return _appenderClose();
  }

  void appenderFlush(int j, bool z) {
    return _appenderFlush(j, z);
  }

  void setConsoleLogOpen(int j, bool z) {
    return _setConsoleLogOpen(j, z);
  }

  void setMaxFileSize(int j, int j1) {
    return _setMaxFileSize(j, j1);
  }

  void setMaxAliveTime(int j, int j1) {
    return _setMaxAliveTime(j, j1);
  }
}

final class $Log_LogImpType extends jni.JObjType<Log_LogImp> {
  const $Log_LogImpType();

  @override
  String get signature => r"Lcom/tencent/mars/xlog/Log$LogImp;";

  @override
  Log_LogImp fromRef(jni.JObjectPtr ref) => Log_LogImp.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Log_LogImpType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Log_LogImpType) && other is $Log_LogImpType;
  }
}

/// from: com.tencent.mars.xlog.Log$LogInstance
class Log_LogInstance extends jni.JObject {
  @override
  late final jni.JObjType<Log_LogInstance> $type = type;

  Log_LogInstance.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Log_LogInstanceType();
  static final _f = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogInstance__f")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void f(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  void f(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _f(reference, string.reference, string1.reference, objects.reference)
        .check();
  }

  static final _e = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogInstance__e")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void e(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  void e(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _e(reference, string.reference, string1.reference, objects.reference)
        .check();
  }

  static final _w = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogInstance__w")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void w(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  void w(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _w(reference, string.reference, string1.reference, objects.reference)
        .check();
  }

  static final _i = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogInstance__i")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void i(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  void i(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _i(reference, string.reference, string1.reference, objects.reference)
        .check();
  }

  static final _d = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogInstance__d")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void d(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  void d(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _d(reference, string.reference, string1.reference, objects.reference)
        .check();
  }

  static final _v = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log_LogInstance__v")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void v(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  void v(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _v(reference, string.reference, string1.reference, objects.reference)
        .check();
  }

  static final _printErrStackTrace = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "Log_LogInstance__printErrStackTrace")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void printErrStackTrace(java.lang.String string, java.lang.Throwable throwable, java.lang.String string1, java.lang.Object[] objects)
  void printErrStackTrace(
    jni.JString string,
    jni.JObject throwable,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _printErrStackTrace(reference, string.reference, throwable.reference,
            string1.reference, objects.reference)
        .check();
  }

  static final _appenderFlush = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log_LogInstance__appenderFlush")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void appenderFlush()
  void appenderFlush() {
    return _appenderFlush(reference).check();
  }

  static final _appenderFlushSync = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log_LogInstance__appenderFlushSync")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void appenderFlushSync()
  void appenderFlushSync() {
    return _appenderFlushSync(reference).check();
  }

  static final _getLogLevel = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log_LogInstance__getLogLevel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getLogLevel()
  int getLogLevel() {
    return _getLogLevel(reference).integer;
  }

  static final _setConsoleLogOpen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Log_LogInstance__setConsoleLogOpen")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setConsoleLogOpen(boolean z)
  void setConsoleLogOpen(
    bool z,
  ) {
    return _setConsoleLogOpen(reference, z ? 1 : 0).check();
  }
}

final class $Log_LogInstanceType extends jni.JObjType<Log_LogInstance> {
  const $Log_LogInstanceType();

  @override
  String get signature => r"Lcom/tencent/mars/xlog/Log$LogInstance;";

  @override
  Log_LogInstance fromRef(jni.JObjectPtr ref) => Log_LogInstance.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Log_LogInstanceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Log_LogInstanceType) &&
        other is $Log_LogInstanceType;
  }
}

/// from: com.tencent.mars.xlog.Log
class Log extends jni.JObject {
  @override
  late final jni.JObjType<Log> $type = type;

  Log.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $LogType();

  /// from: static public final int LEVEL_VERBOSE
  static const LEVEL_VERBOSE = 0;

  /// from: static public final int LEVEL_DEBUG
  static const LEVEL_DEBUG = 1;

  /// from: static public final int LEVEL_INFO
  static const LEVEL_INFO = 2;

  /// from: static public final int LEVEL_WARNING
  static const LEVEL_WARNING = 3;

  /// from: static public final int LEVEL_ERROR
  static const LEVEL_ERROR = 4;

  /// from: static public final int LEVEL_FATAL
  static const LEVEL_FATAL = 5;

  /// from: static public final int LEVEL_NONE
  static const LEVEL_NONE = 6;

  static final _get_toastSupportContext =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Log__toastSupportContext")
          .asFunction<jni.JniResult Function()>();

  static final _set_toastSupportContext = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "set_Log__toastSupportContext")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.content.Context toastSupportContext
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get toastSupportContext =>
      const jni.JObjectType().fromRef(_get_toastSupportContext().object);

  /// from: static public android.content.Context toastSupportContext
  /// The returned object must be released after use, by calling the [release] method.
  static set toastSupportContext(jni.JObject value) =>
      _set_toastSupportContext(value.reference).check();

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Log__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Log() {
    return Log.fromRef(_new0().object);
  }

  static final _setLogImp = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log__setLogImp")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void setLogImp(com.tencent.mars.xlog.Log$LogImp logImp)
  static void setLogImp(
    Log_LogImp logImp,
  ) {
    return _setLogImp(logImp.reference).check();
  }

  static final _getImpl =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Log__getImpl")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.tencent.mars.xlog.Log$LogImp getImpl()
  /// The returned object must be released after use, by calling the [release] method.
  static Log_LogImp getImpl() {
    return const $Log_LogImpType().fromRef(_getImpl().object);
  }

  static final _appenderOpen = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Log__appenderOpen")
      .asFunction<
          jni.JniResult Function(int, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public void appenderOpen(int i, int i1, java.lang.String string, java.lang.String string1, java.lang.String string2, int i2)
  static void appenderOpen(
    int i,
    int i1,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i2,
  ) {
    return _appenderOpen(
            i, i1, string.reference, string1.reference, string2.reference, i2)
        .check();
  }

  static final _appenderClose =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Log__appenderClose")
          .asFunction<jni.JniResult Function()>();

  /// from: static public void appenderClose()
  static void appenderClose() {
    return _appenderClose().check();
  }

  static final _appenderFlush =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Log__appenderFlush")
          .asFunction<jni.JniResult Function()>();

  /// from: static public void appenderFlush()
  static void appenderFlush() {
    return _appenderFlush().check();
  }

  static final _appenderFlushSync =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "Log__appenderFlushSync")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public void appenderFlushSync(boolean z)
  static void appenderFlushSync(
    bool z,
  ) {
    return _appenderFlushSync(z ? 1 : 0).check();
  }

  static final _getLogLevel =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Log__getLogLevel")
          .asFunction<jni.JniResult Function()>();

  /// from: static public int getLogLevel()
  static int getLogLevel() {
    return _getLogLevel().integer;
  }

  static final _setLevel = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Uint8)>>(
          "Log__setLevel")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: static public void setLevel(int i, boolean z)
  static void setLevel(
    int i,
    bool z,
  ) {
    return _setLevel(i, z ? 1 : 0).check();
  }

  static final _setConsoleLogOpen =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Uint8)>>(
              "Log__setConsoleLogOpen")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public void setConsoleLogOpen(boolean z)
  static void setConsoleLogOpen(
    bool z,
  ) {
    return _setConsoleLogOpen(z ? 1 : 0).check();
  }

  static final _f = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__f")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void f(java.lang.String string, java.lang.String string1)
  static void f(
    jni.JString string,
    jni.JString string1,
  ) {
    return _f(string.reference, string1.reference).check();
  }

  static final _e = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__e")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void e(java.lang.String string, java.lang.String string1)
  static void e(
    jni.JString string,
    jni.JString string1,
  ) {
    return _e(string.reference, string1.reference).check();
  }

  static final _w = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__w")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void w(java.lang.String string, java.lang.String string1)
  static void w(
    jni.JString string,
    jni.JString string1,
  ) {
    return _w(string.reference, string1.reference).check();
  }

  static final _i = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__i")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void i(java.lang.String string, java.lang.String string1)
  static void i(
    jni.JString string,
    jni.JString string1,
  ) {
    return _i(string.reference, string1.reference).check();
  }

  static final _d = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__d")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void d(java.lang.String string, java.lang.String string1)
  static void d(
    jni.JString string,
    jni.JString string1,
  ) {
    return _d(string.reference, string1.reference).check();
  }

  static final _v = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__v")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void v(java.lang.String string, java.lang.String string1)
  static void v(
    jni.JString string,
    jni.JString string1,
  ) {
    return _v(string.reference, string1.reference).check();
  }

  static final _f1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__f1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void f(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  static void f1(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _f1(string.reference, string1.reference, objects.reference).check();
  }

  static final _e1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__e1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void e(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  static void e1(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _e1(string.reference, string1.reference, objects.reference).check();
  }

  static final _w1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__w1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void w(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  static void w1(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _w1(string.reference, string1.reference, objects.reference).check();
  }

  static final _i1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__i1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void i(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  static void i1(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _i1(string.reference, string1.reference, objects.reference).check();
  }

  static final _d1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__d1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void d(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  static void d1(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _d1(string.reference, string1.reference, objects.reference).check();
  }

  static final _v1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Log__v1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public void v(java.lang.String string, java.lang.String string1, java.lang.Object[] objects)
  static void v1(
    jni.JString string,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _v1(string.reference, string1.reference, objects.reference).check();
  }

  static final _printErrStackTrace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Log__printErrStackTrace")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void printErrStackTrace(java.lang.String string, java.lang.Throwable throwable, java.lang.String string1, java.lang.Object[] objects)
  static void printErrStackTrace(
    jni.JString string,
    jni.JObject throwable,
    jni.JString string1,
    jni.JArray<jni.JObject> objects,
  ) {
    return _printErrStackTrace(string.reference, throwable.reference,
            string1.reference, objects.reference)
        .check();
  }

  static final _getSysInfo =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Log__getSysInfo")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getSysInfo()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getSysInfo() {
    return const jni.JStringType().fromRef(_getSysInfo().object);
  }

  static final _openLogInstance = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Log__openLogInstance")
      .asFunction<
          jni.JniResult Function(int, int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.tencent.mars.xlog.Log$LogInstance openLogInstance(int i, int i1, java.lang.String string, java.lang.String string1, java.lang.String string2, int i2)
  /// The returned object must be released after use, by calling the [release] method.
  static Log_LogInstance openLogInstance(
    int i,
    int i1,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    int i2,
  ) {
    return const $Log_LogInstanceType().fromRef(_openLogInstance(
            i, i1, string.reference, string1.reference, string2.reference, i2)
        .object);
  }

  static final _closeLogInstance = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log__closeLogInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public void closeLogInstance(java.lang.String string)
  static void closeLogInstance(
    jni.JString string,
  ) {
    return _closeLogInstance(string.reference).check();
  }

  static final _getLogInstance = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Log__getLogInstance")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.tencent.mars.xlog.Log$LogInstance getLogInstance(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Log_LogInstance getLogInstance(
    jni.JString string,
  ) {
    return const $Log_LogInstanceType()
        .fromRef(_getLogInstance(string.reference).object);
  }
}

final class $LogType extends jni.JObjType<Log> {
  const $LogType();

  @override
  String get signature => r"Lcom/tencent/mars/xlog/Log;";

  @override
  Log fromRef(jni.JObjectPtr ref) => Log.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($LogType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($LogType) && other is $LogType;
  }
}
